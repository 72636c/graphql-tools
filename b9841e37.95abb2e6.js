(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{202:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return l})),t.d(n,"default",(function(){return p}));var a=t(3),r=t(7),i=(t(0),t(258)),o={id:"schema-wrapping",title:"Schema wrapping",description:"Wrap schemas to automatically modify schemas, requests and results"},s={unversionedId:"schema-wrapping",id:"schema-wrapping",isDocsHomePage:!1,title:"Schema wrapping",description:"Wrap schemas to automatically modify schemas, requests and results",source:"@site/docs/schema-wrapping.md",slug:"/schema-wrapping",permalink:"/docs/schema-wrapping",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/schema-wrapping.md",version:"current",sidebar:"someSidebar",previous:{title:"Remote schemas",permalink:"/docs/remote-schemas"},next:{title:"Schema merging",permalink:"/docs/schema-merging"}},l=[{value:"Getting started",id:"getting-started",children:[]},{value:"API",id:"api",children:[{value:"Transform",id:"transform",children:[]},{value:"wrapSchema",id:"wrapschema",children:[]}]},{value:"Built-in transforms",id:"built-in-transforms",children:[{value:"Modifying types",id:"modifying-types",children:[]},{value:"Modifying root fields",id:"modifying-root-fields",children:[]},{value:"Modifying object fields",id:"modifying-object-fields",children:[]},{value:"Additional Operation Transforms",id:"additional-operation-transforms",children:[]}]},{value:"delegateToSchema (delegation) transforms",id:"delegatetoschema-delegation-transforms",children:[]},{value:"stitchSchemas (gateway/stitching) transforms",id:"stitchschemas-gatewaystitching-transforms",children:[]}],c={toc:l};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Schema wrapping (",Object(i.b)("inlineCode",{parentName:"p"},"@graphql-tools/wrap"),') creates a modified version of a schema that proxies, or "wraps", the original unmodified schema. This technique is particularily useful when the original schema ',Object(i.b)("em",{parentName:"p"},"cannot")," be changed, such as with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/remote-schemas/"}),"remote schemas"),"."),Object(i.b)("p",null,"Schema wrapping works by wrapping the original schema in a new 'gateway' schema that simply delegates all operations to the original subschema. A series of 'transforms' are applied to modify the schema after the initial wrapping is complete. Each transform includes a schema transformation function that changes the gateway schema. It may also include operation transforms, i.e. functions that either modify the operation prior to delegation or modify the result prior to its return."),Object(i.b)("h2",{id:"getting-started"},"Getting started"),Object(i.b)("p",null,"For example, let's consider changing the name of the type in a simple schema. Imagine we've written a function that takes a ",Object(i.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," and replaces all instances of type ",Object(i.b)("inlineCode",{parentName:"p"},"Test")," with ",Object(i.b)("inlineCode",{parentName:"p"},"NewTest"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"# old schema\ntype Test {\n  id: ID!\n  name: String\n}\n\ntype Query {\n  returnTest: Test\n}\n\n# new schema\n\ntype NewTest {\n  id: ID!\n  name: String\n}\n\ntype Query {\n  returnTest: NewTest\n}\n")),Object(i.b)("p",null,"On delegation to the original subschema, we want the ",Object(i.b)("inlineCode",{parentName:"p"},"NewTest")," type to be automatically mapped to the old ",Object(i.b)("inlineCode",{parentName:"p"},"Test")," type."),Object(i.b)("p",null,"At first glance, it might seem as though most queries work the same way as before:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"query {\n  returnTest {\n    id\n    name\n  }\n}\n")),Object(i.b)("p",null,"Since the fields of the type have not changed, delegating to the old schema is relatively easy here."),Object(i.b)("p",null,"However, the new name begins to matter more when fragments and variables are used:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"query {\n  returnTest {\n    id\n    ... on NewTest {\n      name\n    }\n  }\n}\n")),Object(i.b)("p",null,"Since the ",Object(i.b)("inlineCode",{parentName:"p"},"NewTest")," type did not exist on old schema, this fragment will not match anything in the old schema, so it will be filtered out during delegation."),Object(i.b)("p",null,"What we need is a ",Object(i.b)("inlineCode",{parentName:"p"},"transformRequest")," function that knows how to rename any occurrences of ",Object(i.b)("inlineCode",{parentName:"p"},"NewTest")," to ",Object(i.b)("inlineCode",{parentName:"p"},"Test")," before delegating to the old schema."),Object(i.b)("p",null,"By the same reasoning, we also need a ",Object(i.b)("inlineCode",{parentName:"p"},"transformResult")," function, because any results contain a ",Object(i.b)("inlineCode",{parentName:"p"},"__typename")," field whose value is ",Object(i.b)("inlineCode",{parentName:"p"},"Test"),", that name needs to be updated to ",Object(i.b)("inlineCode",{parentName:"p"},"NewTest")," in the final result."),Object(i.b)("h2",{id:"api"},"API"),Object(i.b)("h3",{id:"transform"},"Transform"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export interface Transform<T = Record<string, any>> {\n  transformSchema?: SchemaTransform;\n  transformRequest?: RequestTransform<T>;\n  transformResult?: ResultTransform<T>;\n}\n\nexport type SchemaTransform = (\n  originalWrappingSchema: GraphQLSchema,\n  subschemaConfig: SubschemaConfig,\n  transformedSchema?: GraphQLSchema\n) => GraphQLSchema;\n\nexport type RequestTransform<T = Record<string, any>> = (\n  originalRequest: Request,\n  delegationContext: DelegationContext,\n  transformationContext: T\n) => Request;\n\nexport type ResultTransform<T = Record<string, any>> = (\n  originalResult: ExecutionResult,\n  delegationContext: DelegationContext,\n  transformationContext: T\n) => ExecutionResult;\n\ntype Request = {\n  document: DocumentNode;\n  variables: Record<string, any>;\n  extensions?: Record<string, any>;\n};\n")),Object(i.b)("h3",{id:"wrapschema"},"wrapSchema"),Object(i.b)("p",null,"Given a ",Object(i.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," and an array of ",Object(i.b)("inlineCode",{parentName:"p"},"Transform")," objects, ",Object(i.b)("inlineCode",{parentName:"p"},"wrapSchema")," produces a new schema with the ",Object(i.b)("inlineCode",{parentName:"p"},"transformSchema")," methods applied."),Object(i.b)("p",null,"Delegating resolvers are generated to map from new schema root fields to old schema root fields. These automatic resolvers should be sufficient, so you don't have to implement your own."),Object(i.b)("p",null,"The delegating resolvers will apply the operation transforms defined by the ",Object(i.b)("inlineCode",{parentName:"p"},"Transform")," objects. Each provided ",Object(i.b)("inlineCode",{parentName:"p"},"transformRequest")," functions will be applies in reverse order, until the request matches the original schema. The ",Object(i.b)("inlineCode",{parentName:"p"},"tranformResult")," functions will be applied in the opposite order until the result matches the final gateway schema."),Object(i.b)("p",null,"In advanced cases, transforms may wish to create additional delegating root resolvers (for example, when hoisting a field into a root type). This is also possible. The wrapping schema is actually generated twice -- the first run results in a possibly non-executable version, while the second execution also includes the result of the first one within the ",Object(i.b)("inlineCode",{parentName:"p"},"transformedSchema")," argument so that an executable version with any new proxying resolvers can be created."),Object(i.b)("p",null,"Remote schemas can also be wrapped! In fact, this is the primary use case. See documentation regarding ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/remote-schemas/"}),"remote schemas")," for further details about remote schemas. Note that as explained there, when wrapping remote schemas, you will be wrapping a subschema config object, and the array of transforms should be defined on that object rather than as a second argument to ",Object(i.b)("inlineCode",{parentName:"p"},"wrapSchema"),"."),Object(i.b)("h2",{id:"built-in-transforms"},"Built-in transforms"),Object(i.b)("p",null,"Built-in transforms are ready-made classes implementing the ",Object(i.b)("inlineCode",{parentName:"p"},"Transform")," interface. They are intended to cover many of the most common schema transformation use cases, but they also serve as examples of how to implement transforms for your own needs."),Object(i.b)("h3",{id:"modifying-types"},"Modifying types"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"FilterTypes(filter: (type: GraphQLNamedType) => boolean)"),": Remove all types for which the ",Object(i.b)("inlineCode",{parentName:"p"},"filter")," function returns ",Object(i.b)("inlineCode",{parentName:"p"},"false"),".")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"RenameTypes(renamer, options?)"),": Rename types by applying ",Object(i.b)("inlineCode",{parentName:"p"},"renamer")," to each type name. If ",Object(i.b)("inlineCode",{parentName:"p"},"renamer")," returns ",Object(i.b)("inlineCode",{parentName:"p"},"undefined"),", the name will be left unchanged. Options controls whether built-in types and scalars are renamed. Root objects are never renamed by this transform."))),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"RenameTypes(\n  (name: string) => string | void,\n  options?: {\n    renameBuiltins: Boolean;\n    renameScalars: Boolean;\n  },\n)\n")),Object(i.b)("h3",{id:"modifying-root-fields"},"Modifying root fields"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"TransformRootFields(transformer: RootTransformer)"),": Given a transformer, arbitrarily transform root fields. The ",Object(i.b)("inlineCode",{parentName:"li"},"transformer")," can return a ",Object(i.b)("inlineCode",{parentName:"li"},"GraphQLFieldConfig")," definition, a object with new ",Object(i.b)("inlineCode",{parentName:"li"},"name")," and a ",Object(i.b)("inlineCode",{parentName:"li"},"field"),", ",Object(i.b)("inlineCode",{parentName:"li"},"null")," to remove the field, or ",Object(i.b)("inlineCode",{parentName:"li"},"undefined")," to leave the field unchanged.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"TransformRootFields(transformer: RootTransformer)\n\ntype RootTransformer = (\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  fieldName: string,\n  fieldConfig: GraphQLField<any, any>,\n) =>\n  | GraphQLFieldConfig<any, any>\n  | [string, GraphQLFieldConfig<any, any>]\n  | null\n  | void;\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"FilterRootFields(filter: RootFilter)"),": Like ",Object(i.b)("inlineCode",{parentName:"li"},"FilterTypes"),", removes root fields for which the ",Object(i.b)("inlineCode",{parentName:"li"},"filter")," function returns ",Object(i.b)("inlineCode",{parentName:"li"},"false"),".")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"FilterRootFields(filter: RootFilter)\n\ntype RootFilter = (\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  fieldName: string,\n  fieldConfig: GraphQLFieldConfig<any, any>,\n) => boolean;\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"RenameRootFields(renamer)"),": Rename root fields, by applying the ",Object(i.b)("inlineCode",{parentName:"li"},"renamer")," function to their names.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"RenameRootFields(\n  renamer: (\n    operation: 'Query' | 'Mutation' | 'Subscription',\n    name: string,\n    fieldConfig: GraphQLFieldConfig<any, any>,\n  ) => string,\n)\n")),Object(i.b)("h3",{id:"modifying-object-fields"},"Modifying object fields"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"TransformObjectFields(objectFieldTransformer: FieldTransformer, fieldNodeTransformer?: FieldNodeTransformer))"),": Given a field transformer, arbitrarily transform fields. The ",Object(i.b)("inlineCode",{parentName:"li"},"objectFieldTransformer")," can return a ",Object(i.b)("inlineCode",{parentName:"li"},"GraphQLFieldConfig")," definition, an array with first member being the new field name and second member being the new ",Object(i.b)("inlineCode",{parentName:"li"},"GraphQLFieldConfig")," definition, ",Object(i.b)("inlineCode",{parentName:"li"},"null")," to remove the field, or ",Object(i.b)("inlineCode",{parentName:"li"},"undefined")," to leave the field unchanged. The optional ",Object(i.b)("inlineCode",{parentName:"li"},"fieldNodeTransformer"),", if specified, is called upon any field of that type in the request; result transformation can be specified by wrapping the field's resolver within the ",Object(i.b)("inlineCode",{parentName:"li"},"objectFieldTransformer"),".")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"TransformObjectFields(objectFieldTransformer: FieldTransformer, fieldNodeTransformer: FieldNodeTransformer)\n\nexport type FieldTransformer = (\n  typeName: string,\n  fieldName: string,\n  fieldConfig: GraphQLFieldConfig<any, any>,\n) =>\n  | GraphQLFieldConfig<any, any>\n  | [string, GraphQLFieldConfig<any, any>]\n  | null\n  | undefined;\n\nexport type FieldNodeTransformer = (\n  typeName: string,\n  fieldName: string,\n  fieldNode: FieldNode,\n  fragments: Record<string, FragmentDefinitionNode>\n) => SelectionNode | Array<SelectionNode>;\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"FilterObjectFields(filter: ObjectFilter)"),": Removes object fields for which the ",Object(i.b)("inlineCode",{parentName:"li"},"filter")," function returns ",Object(i.b)("inlineCode",{parentName:"li"},"false"),".")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"FilterObjectFields(filter: ObjectFilter)\n\ntype ObjectFilter = (\n  typeName: string,\n  fieldName: string,\n  fieldConfig: GraphQLFieldConfig<any, any>,\n) => boolean;\n")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"RenameObjectFields(renamer)"),": Rename object fields, by applying the ",Object(i.b)("inlineCode",{parentName:"li"},"renamer")," function to their names.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"RenameObjectFields(\n  renamer: (\n    typeName: string,\n    fieldName: string,\n    fieldConfig: GraphQLFieldConfig<any, any>,\n  ) => string,\n)\n")),Object(i.b)("h3",{id:"additional-operation-transforms"},"Additional Operation Transforms"),Object(i.b)("p",null,"It may be sometimes useful to add additional transforms to manually change an operation request or result when using ",Object(i.b)("inlineCode",{parentName:"p"},"delegateToSchema"),". Common use cases may be move selections around or to wrap them. The following built-in transforms may be useful in those cases."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"ExtractField({ from: Array<string>, to: Array<string> })")," - move selection at ",Object(i.b)("inlineCode",{parentName:"p"},"from")," path to ",Object(i.b)("inlineCode",{parentName:"p"},"to")," path.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"WrapQuery(\n  path: Array<string>,\n  wrapper: QueryWrapper,\n  extractor: (result: any) => any,\n)")," - wrap a selection at ",Object(i.b)("inlineCode",{parentName:"p"},"path")," using function ",Object(i.b)("inlineCode",{parentName:"p"},"wrapper"),". Apply ",Object(i.b)("inlineCode",{parentName:"p"},"extractor")," at the same path to get the result. This is used to get a result nested inside other result"))),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"transforms: [\n  // Wrap document takes a subtree as an AST node\n  new WrapQuery(\n    // path at which to apply wrapping and extracting\n    ['userById'],\n    (subtree: SelectionSetNode) => ({\n      // we create a wrapping AST Field\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        // that field is `address`\n        value: 'address',\n      },\n      // Inside the field selection\n      selectionSet: subtree,\n    }),\n    // how to process the data result at path\n    result => result && result.address,\n  ),\n],\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"WrapQuery")," can also be used to expand multiple top level query fields"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"transforms: [\n  // Wrap document takes a subtree as an AST node\n  new WrapQuery(\n    // path at which to apply wrapping and extracting\n    ['userById'],\n    (subtree: SelectionSetNode) => {\n      const newSelectionSet = {\n        kind: Kind.SELECTION_SET,\n        selections: subtree.selections.map(selection => {\n          // just append fragments, not interesting for this\n          // test\n          if (selection.kind === Kind.INLINE_FRAGMENT ||\n            selection.kind === Kind.FRAGMENT_SPREAD) {\n            return selection;\n          }\n          // prepend `address` to name and camelCase\n          const oldFieldName = selection.name.value;\n          return {\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: 'address' +\n                oldFieldName.charAt(0).toUpperCase() +\n                oldFieldName.slice(1)\n            }\n          };\n        })\n      };\n      return newSelectionSet;\n    },\n    // how to process the data result at path\n    result => ({\n      streetAddress: result.addressStreetAddress,\n      zip: result.addressZip\n    })\n")),Object(i.b)("h2",{id:"delegatetoschema-delegation-transforms"},"delegateToSchema (delegation) transforms"),Object(i.b)("p",null,"The following transforms are automatically applied by ",Object(i.b)("inlineCode",{parentName:"p"},"delegateToSchema")," during schema delegation, to translate between source and target types and fields:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ExpandAbstractTypes"),": If an abstract type within a document does not exist within the target schema, expand the type to each and any of its implementations that do exist."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"FilterToSchema"),": Remove all fields, variables and fragments for types that don't exist within the target schema."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"AddTypenameToAbstract"),": Add ",Object(i.b)("inlineCode",{parentName:"li"},"__typename")," to all abstract types in the document, necessary for type resolution of interfaces within the source schema to work."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"CheckResultAndHandleErrors"),": Given a result from a subschema, propagate errors so that they match the correct subfield. Also provide the correct key if aliases are used.")),Object(i.b)("p",null,"By passing a custom ",Object(i.b)("inlineCode",{parentName:"p"},"transforms")," array to ",Object(i.b)("inlineCode",{parentName:"p"},"delegateToSchema"),", it's possible to run additional operation (request/result) transforms before these default transforms."),Object(i.b)("h2",{id:"stitchschemas-gatewaystitching-transforms"},"stitchSchemas (gateway/stitching) transforms"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"AddReplacementSelectionSets(schema: GraphQLSchema, mapping: ReplacementSelectionSetMapping)"),":  ",Object(i.b)("inlineCode",{parentName:"li"},"stitchSchemas")," adds selection sets on outgoing requests from the gateway, enabling delegation from fields specified on the gateway using fields obtained from the original requests. The selection sets can be added depending on the presence of fields within the request using the ",Object(i.b)("inlineCode",{parentName:"li"},"selectionSet")," option within the resolver map.  ",Object(i.b)("inlineCode",{parentName:"li"},"stitchSchemas")," creates the mapping at gateway startup. Selection sets are used instead of fragments as the selections are added prior to transformation in case type names are changed, obviating the need for the fragment name."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"AddMergedTypeSelectionSets(schema: GraphQLSchema, mapping: Record<string, MergedTypeInfo>)"),": ",Object(i.b)("inlineCode",{parentName:"li"},"stitchSchemas")," adds selection sets on outgoing requests from the gateway, enabling type merging from the initial result using any fields initially obtained. The mapping is created at gateway startup.")))}p.isMDXComponent=!0},258:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return u}));var a=t(0),r=t.n(a);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=r.a.createContext({}),p=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=p(e.components);return r.a.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},b=r.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),b=a,u=d["".concat(o,".").concat(b)]||d[b]||m[b]||i;return t?r.a.createElement(u,s(s({ref:n},c),{},{components:t})):r.a.createElement(u,s({ref:n},c))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=b;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);