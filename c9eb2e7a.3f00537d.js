(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{182:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return m}));var a=n(3),r=n(7),s=(n(0),n(208)),i={id:"stitch-combining-schemas",title:"Combining schemas",sidebar_label:"Combining schemas"},o={unversionedId:"stitch-combining-schemas",id:"stitch-combining-schemas",isDocsHomePage:!1,title:"Combining schemas",description:"Schema stitching (@graphql-tools/stitch) creates a single GraphQL gateway schema from multiple underlying GraphQL services. Unlike schema merging, which simply combines local schema instances, stitching builds a combined proxy layer that delegates requests through to underlying service APIs. Stitching is a comperable alternative to Apollo Federation.",source:"@site/docs/stitch-combining-schemas.md",slug:"/stitch-combining-schemas",permalink:"/docs/stitch-combining-schemas",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/stitch-combining-schemas.md",version:"current",sidebar_label:"Combining schemas",sidebar:"someSidebar",previous:{title:"Schema merging",permalink:"/docs/schema-merging"},next:{title:"Type merging",permalink:"/docs/stitch-type-merging"}},c=[{value:"Why stitching?",id:"why-stitching",children:[]},{value:"Getting started",id:"getting-started",children:[]},{value:"Subschema configs",id:"subschema-configs",children:[]},{value:"Stitching remote schemas",id:"stitching-remote-schemas",children:[]},{value:"Duplicate types",id:"duplicate-types",children:[{value:"Automatic merge",id:"automatic-merge",children:[]},{value:"Manual resolution",id:"manual-resolution",children:[]}]},{value:"Adding transforms",id:"adding-transforms",children:[]},{value:"Error handling",id:"error-handling",children:[]}],l={rightToc:c};function m(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"Schema stitching (",Object(s.b)("inlineCode",{parentName:"p"},"@graphql-tools/stitch"),") creates a single GraphQL gateway schema from multiple underlying GraphQL services. Unlike ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/merge-schemas"}),"schema merging"),", which simply combines local schema instances, stitching builds a combined proxy layer that delegates requests through to underlying service APIs. Stitching is a comperable alternative to ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.apollographql.com/docs/federation/"}),"Apollo Federation"),"."),Object(s.b)("h2",{id:"why-stitching"},"Why stitching?"),Object(s.b)("p",null,"One of the main benefits of GraphQL is that we can query for all data in a single request to one schema. As that schema grows though, it may become preferable to break it up into seperate modules or microservices that can be developed independently. We may also want to integrate the schemas we own with third-party schemas, allowing mashups with external data."),Object(s.b)("p",null,"In these cases, ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," is used to combine multiple GraphQL APIs into one unified gateway schema that knows how to delegate parts of a request to the relevant underlying subschemas. These subschemas may be local GraphQL instances or APIs running on remote servers."),Object(s.b)("h2",{id:"getting-started"},"Getting started"),Object(s.b)("p",null,"In this example we'll stitch together two very simple schemas. We'll be dealing with a system of users and posts."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { makeExecutableSchema } from '@graphql-tools/schema';\nimport { stitchSchemas } from '@graphql-tools/stitch';\n\nlet postsSchema = makeExecutableSchema({\n  typeDefs: `\n    type Post {\n      id: ID!\n      text: String\n      userId: ID!\n    }\n\n    type Query {\n      postById(id: ID!): Post\n      postsByUserId(userId: ID!): [Post]!\n    }\n  `,\n  resolvers: { ... }\n});\n\nlet usersSchema = makeExecutableSchema({\n  typeDefs: `\n    type User {\n      id: ID!\n      email: String\n    }\n\n    type Query {\n      userById(id: ID!): User\n    }\n  `,\n  resolvers: { ... }\n});\n\n// setup subschema configurations\nexport const postsSubschema = { schema: postsSchema };\nexport const usersSubschema = { schema: usersSchema };\n\n// build the combined schema\nexport const gatewaySchema = stitchSchemas({\n  subschemas: [\n    postsSubschema,\n    usersSubschema,\n  ]\n});\n")),Object(s.b)("p",null,"This process builds two GraphQL schemas, places them each into subschema configuration wrappers (discussed below), and then passes the subschemas to ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," to produce one combined schema with the following root fields:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"type Query {\n  postById(id: ID!): Post\n  postsByUserId(userId: ID!): [Post]!\n  userById(id: ID!): User\n}\n")),Object(s.b)("p",null,"We now have a single gateway schema that allows data from either subschema to be requested in the same query."),Object(s.b)("h2",{id:"subschema-configs"},"Subschema configs"),Object(s.b)("p",null,'In the example above, the extra "subschema" wrapper objects may look verbose at first glance, but they are actually basic implementations of the ',Object(s.b)("inlineCode",{parentName:"p"},"SubschemaConfig")," interface that accepts several additional settings (discussed throughout this guide):"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"export interface SubschemaConfig {\n  schema: GraphQLSchema;\n  rootValue?: Record<string, any>;\n  executor?: Executor;\n  subscriber?: Subscriber;\n  createProxyingResolver?: CreateProxyingResolverFn;\n  transforms?: Array<Transform>;\n  merge?: Record<string, MergedTypeConfig>;\n  batch?: boolean;\n  batchingOptions?: {\n    extensionsReducer?: (mergedExtensions: Record<string, any>, executionParams: ExecutionParams) => Record<string, any>;\n    dataLoaderOptions?: DataLoader.Options<K, V, C>;\n  }\n}\n")),Object(s.b)("p",null,"Subschema config should ",Object(s.b)("em",{parentName:"p"},"directly")," provide as many settings as possible to avoid unnecessary layers of delegation. For example, while we ",Object(s.b)("em",{parentName:"p"},"could")," pre-wrap a subschema with transforms and a remote executor, that would be far less efficient than providing the ",Object(s.b)("inlineCode",{parentName:"p"},"schema"),", ",Object(s.b)("inlineCode",{parentName:"p"},"transforms"),", and ",Object(s.b)("inlineCode",{parentName:"p"},"executor")," options directly to subschema config."),Object(s.b)("p",null,"Also note that these subschema config objects may need to be referenced again in other stitching contexts, such as ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/stitch-schema-extensions"}),"schema extensions"),". With that in mind, you may want to export your subschema configs from their module(s)."),Object(s.b)("h2",{id:"stitching-remote-schemas"},"Stitching remote schemas"),Object(s.b)("p",null,"To include a remote schema in the combined gateway, we must provide at least the ",Object(s.b)("inlineCode",{parentName:"p"},"schema")," and ",Object(s.b)("inlineCode",{parentName:"p"},"executor")," subschema config options:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { buildSchema } from 'graphql';\nimport { linkToExecutor } from '@graphql-tools/links';\n\nexport const postsSubschema = {\n  schema: buildSchema(postsServiceTypeDefs),\n  executor: linkToExecutor(postsServiceLink),\n};\n")),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"schema"),": this is a non-executable schema representing the remote API. The remote schema's SDL (schema definition language) may be obtained through a dedicated service (similar to the ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.apollographql.com/docs/federation/federation-spec/#query_service"}),"federation service spec"),"), or using ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/remote-schemas/#introspectschemaexecutor-context"}),"introspection"),". Note that not all GraphQL servers enable introspection, and those that do will not include custom directives."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"executor"),": is a generic method that performs requests to a remote schema. You may ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/remote-schemas#creating-an-executor"}),"write your own"),", or use the ",Object(s.b)("inlineCode",{parentName:"li"},"linkToExecutor")," helper to wrap a ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.npmjs.com/package/apollo-link-http"}),"link package"),". Subschema config uses the ",Object(s.b)("inlineCode",{parentName:"li"},"executor")," for query and mutation operations, and accepts a ",Object(s.b)("inlineCode",{parentName:"li"},"subscriber")," function for subscription operations.")),Object(s.b)("p",null,"See ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/remote-schemas/"}),"remote schemas")," documentation for more related tools and information."),Object(s.b)("h2",{id:"duplicate-types"},"Duplicate types"),Object(s.b)("p",null,"Stitching has two strategies for handling types duplicated across subschemas: an automatic merge strategy (default), and an older manual resolution strategy. You may select between these strategies using the ",Object(s.b)("inlineCode",{parentName:"p"},"mergeTypes")," option."),Object(s.b)("h3",{id:"automatic-merge"},"Automatic merge"),Object(s.b)("p",null,"Types with the same name are automatically merged by default in GraphQL Tools v7. That means objects, interfaces, and input objects with the same name will have their fields consolidated from across subschemas, and unions/enums will consolidate all members. The combined gateway schema will then smartly delegate portions of a request to the proper origin subschema(s). See ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/stitch-type-merging/"}),"type merging guide")," for a comprehensive overview."),Object(s.b)("p",null,"Automatic merging will only encounter conflicts on fields and type descriptions. By default, the final definition of a field or type description found in the subschemas array is used. You may customize this selection logic in ",Object(s.b)("inlineCode",{parentName:"p"},"typeMergingOptions"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const gatewaySchema = stitchSchemas({\n  subschemas: [...],\n  mergeTypes: true, // << optional in v7\n  typeMergingOptions: {\n    typeDescriptionsMerger(candidates) {\n      const candidate = candidates.find(({ type }) => !!type.description) || candidates.pop();\n      return candidate.type.description;\n    },\n    fieldConfigMerger(candidates) {\n      const configs = candidates.map(c => c.fieldConfig);\n      return configs.find(({ description }) => !!description) || configs.pop();\n    },\n    inputFieldConfigMerger(candidates) {\n      const configs = candidates.map(c => c.inputFieldConfig);\n      return configs.find(({ description }) => !!description) || configs.pop();\n    }\n  },\n});\n")),Object(s.b)("p",null,"In the example above, the first non-blank description encountered for each type and field in the subschemas array will be used."),Object(s.b)("h3",{id:"manual-resolution"},"Manual resolution"),Object(s.b)("p",null,"By setting ",Object(s.b)("inlineCode",{parentName:"p"},"mergeTypes: false"),", only the final description and fields for a type found in the subschemas array will be used. You may manually resolve differences between conflicting types with an ",Object(s.b)("inlineCode",{parentName:"p"},"onTypeConflict")," handler:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const gatewaySchema = stitchSchemas({\n  subschemas: [...],\n  mergeTypes: false,\n  onTypeConflict: (left, right, info) => {\n    return info.left.schema.version >= info.right.schema.version ? left : right;\n  }\n});\n")),Object(s.b)("h2",{id:"adding-transforms"},"Adding transforms"),Object(s.b)("p",null,"Another strategy to avoid conflicts while combining schemas is to modify one or more of the subschemas using ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/schema-wrapping#transform"}),"transforms"),". Transforming allows a schema to be groomed in such ways as adding namespaces, renaming types, or removing fields (to name a few) prior to stitching it into the combined gateway schema. These transforms should be added directly to subschema config:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { FilterRootFields, RenameTypes } from '@graphql-tools/wrap';\n\nconst postsSubschema = {\n  schema: postsSchema,\n  transforms: [\n    new FilterRootFields((operation, rootField) => rootField !== 'postsByUserId'),\n    new RenameTypes((name) => `Post_${name}`),\n  ],\n};\n")),Object(s.b)("p",null,"In the example above, we transform the ",Object(s.b)("inlineCode",{parentName:"p"},"postsSchema")," by removing the ",Object(s.b)("inlineCode",{parentName:"p"},"postsByUserId")," root field and adding a ",Object(s.b)("inlineCode",{parentName:"p"},"Post_")," prefix to all types in the schema. These modifications will only be present in the combined gateway schema."),Object(s.b)("p",null,"Note that when ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"#automatic-merge"}),"automatically merging types"),", all transforms are applied ",Object(s.b)("em",{parentName:"p"},"prior")," to merging. That means transformed types will merge based on their transformed names within the combined gateway schema."),Object(s.b)("h2",{id:"error-handling"},"Error handling"),Object(s.b)("p",null,"Whether you're ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/stitch-type-merging"}),"merging types"),", using ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/stitch-schema-extensions"}),"schema extensions"),", or simply combining schemas, any errors returned by a subschema will flow through the stitching process and report at their mapped output positions. It's fairly seamless to provide quality errors from a stitched schema by following some basic guidelines:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},Object(s.b)("p",{parentName:"li"},Object(s.b)("strong",{parentName:"p"},"Report errors!")," Having a subschema return ",Object(s.b)("inlineCode",{parentName:"p"},"null")," without an error for missing or failed records is a poor development experience to begin with. This omission will compound should an unexpected value produce a misleading failure in gateway stitching. Reporting ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://spec.graphql.org/June2018/#sec-Errors"}),"proper GraphQL errors")," will contexualize failures in subschemas, and by extension, within the stitched schema.")),Object(s.b)("li",{parentName:"ol"},Object(s.b)("p",{parentName:"li"},Object(s.b)("strong",{parentName:"p"},"Map errors to array positions"),". When returning arrays of records (a common pattern while ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/stitch-type-merging#batching"}),"batch loading"),"), make sure to return errors for specific array positions rather than erroring out the entire array. For example, an array should be resolved as:"))),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"posts() {\n  return [\n    { id: '1', ... },\n    new NotFoundError(),\n    { id: '3', ... },\n  ];\n}\n")),Object(s.b)("ol",{start:3},Object(s.b)("li",{parentName:"ol"},Object(s.b)("strong",{parentName:"li"},"Assure valid error paths"),". The ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://spec.graphql.org/June2018/#sec-Errors"}),"GraphQL errors spec")," prescribes a ",Object(s.b)("inlineCode",{parentName:"li"},"path")," attribute mapping an error to its corresponding document position. Stitching uses these paths to remap subschema errors into the combined result. While GraphQL libraries should automatically configure this ",Object(s.b)("inlineCode",{parentName:"li"},"path")," for you, the accuracy ",Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/rmosolgo/graphql-ruby/issues/3193"}),"may vary by programming language"),".")))}m.isMDXComponent=!0},208:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),m=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=m(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=m(n),b=a,d=p["".concat(i,".").concat(b)]||p[b]||h[b]||s;return n?r.a.createElement(d,o(o({ref:t},l),{},{components:n})):r.a.createElement(d,o({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=b;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var l=2;l<s;l++)i[l]=n[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);