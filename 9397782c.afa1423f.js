(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{130:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return l}));var a=n(2),r=n(6),s=(n(0),n(189)),i={id:"schema-stitching",title:"Schema stitching",description:"Combining multiple GraphQL APIs into one"},o={unversionedId:"schema-stitching",id:"schema-stitching",isDocsHomePage:!1,title:"Schema stitching",description:"Combining multiple GraphQL APIs into one",source:"@site/docs/schema-stitching.md",permalink:"/docs/schema-stitching",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/schema-stitching.md",sidebar:"someSidebar",previous:{title:"GraphQLSchema merging",permalink:"/docs/merge-schemas"},next:{title:"Setup an HTTP server",permalink:"/docs/server-setup"}},c=[{value:"Basic example",id:"basic-example",children:[{value:"Adding resolvers between schemas",id:"adding-resolvers-between-schemas",children:[]},{value:"Passing arguments between resolvers",id:"passing-arguments-between-resolvers",children:[]},{value:"Batch Delegation",id:"batch-delegation",children:[]}]},{value:"Using with Transforms",id:"using-with-transforms",children:[]},{value:"Merging types",id:"merging-types",children:[]},{value:"Working with remote schemas",id:"working-with-remote-schemas",children:[]},{value:"API",id:"api",children:[{value:"subschemas",id:"subschemas",children:[]},{value:"types",id:"types",children:[]},{value:"typeDefs",id:"typedefs",children:[]},{value:"resolvers",id:"resolvers",children:[]},{value:"delegateToSchema",id:"delegatetoschema",children:[]}]}],h={rightToc:c};function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},h,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"Schema stitching is the process of creating a single GraphQL schema from multiple underlying GraphQL APIs."),Object(s.b)("p",null,"One of the main benefits of GraphQL is that we can query all of our data as part of one schema, and get everything we need in one request. But as the schema grows, it might become cumbersome to manage it all as one codebase, and it starts to make sense to split it into different modules. We may also want to decompose your schema into separate microservices, which can be developed and deployed independently. We may also want to integrate our own schema with remote schemas."),Object(s.b)("p",null,"In these cases, we use ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," to combine multiple GraphQL schemas together and produce a new schema that knows how to delegate parts of the query to the relevant subschemas. These subschemas can be either local to the server, or running on a remote server. They can even be services offered by 3rd parties, allowing us to connect to external data and create mashups."),Object(s.b)("h2",{id:"basic-example"},"Basic example"),Object(s.b)("p",null,"In this example we'll stitch together two very simple schemas. In this case, we're dealing with two schemas that implement a system with users and \"chirps\"","\u2014","small snippets of text that users can post."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { makeExecutableSchema } from '@graphql-tools/schema';\nimport { addMocksToSchema } from '@graphql-tools/mock';\nimport { stitchSchemas } from '@graphql-tools/stitch';\n\n// Mocked chirp schema\n// We don't worry about the schema implementation right now since we're just\n// demonstrating schema stitching.\nlet chirpSchema = makeExecutableSchema({\n  typeDefs: `\n    type Chirp {\n      id: ID!\n      text: String\n      authorId: ID!\n    }\n\n    type Query {\n      chirpById(id: ID!): Chirp\n      chirpsByAuthorId(authorId: ID!): [Chirp]\n    }\n  `\n});\n\nchirpSchema = addMocksToSchema({ schema: chirpSchema });\n\n// Mocked author schema\nlet authorSchema = makeExecutableSchema({\n  typeDefs: `\n    type User {\n      id: ID!\n      email: String\n    }\n\n    type Query {\n      userById(id: ID!): User\n    }\n  `\n});\n\nauthorSchema = addMocksToSchema({ schema: authorSchema });\n\nexport const schema = stitchSchemas({\n  subschemas: [\n    { schema: chirpSchema, },\n    { schema: authorSchema, },\n  ],\n});\n")),Object(s.b)("p",null,"Note the new ",Object(s.b)("inlineCode",{parentName:"p"},"subschemas")," property with an array of subschema configuration objects. This syntax is a bit more verbose, but we shall see how it provides multiple benefits:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"transforms should be specified on the subschema config object, avoiding creation of a new schema with a new round of delegation in order to transform a schema prior to merging. This also makes it simple to include the necessary transforms when delegating, as you will pass the entire subschema configuration object to ",Object(s.b)("inlineCode",{parentName:"li"},"delegateToSchema")," instead of just the schema, with the required transforms included for free."),Object(s.b)("li",{parentName:"ol"},"remote subschema configuration options can be specified, also avoiding an additional round of schema proxying. That's three rounds of delegations reduce to one!")),Object(s.b)("p",null,"This gives us a new schema with the root fields on ",Object(s.b)("inlineCode",{parentName:"p"},"Query")," from both schemas (along with the ",Object(s.b)("inlineCode",{parentName:"p"},"User")," and ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp")," types):"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"type Query {\n  chirpById(id: ID!): Chirp\n  chirpsByAuthorId(authorId: ID!): [Chirp]\n  userById(id: ID!): User\n}\n")),Object(s.b)("p",null,"We now have a single schema that supports asking for ",Object(s.b)("inlineCode",{parentName:"p"},"userById")," and ",Object(s.b)("inlineCode",{parentName:"p"},"chirpsByAuthorId")," in the same query!"),Object(s.b)("h3",{id:"adding-resolvers-between-schemas"},"Adding resolvers between schemas"),Object(s.b)("p",null,"Combining existing root fields is a great start, but in practice we will often want to introduce additional fields for working with the relationships between types that came from different subschemas. For example, we might want to go from a particular user to their chirps, or from a chirp to its author. Or we might want to query a ",Object(s.b)("inlineCode",{parentName:"p"},"latestChirps")," field and then get the author of each of those chirps. If the only way to obtain a chirp's author is to call the ",Object(s.b)("inlineCode",{parentName:"p"},"userById(id)")," root query field with the ",Object(s.b)("inlineCode",{parentName:"p"},"authorId")," of a given chirp, and we don't know the chirp's ",Object(s.b)("inlineCode",{parentName:"p"},"authorId")," until we receive the GraphQL response, then we won't be able to obtain the authors as part of the same query."),Object(s.b)("p",null,"To add this ability to navigate between types, we need to ",Object(s.b)("em",{parentName:"p"},"extend")," existing types with new fields that translate between the types:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const linkTypeDefs = `\n  extend type User {\n    chirps: [Chirp]\n  }\n\n  extend type Chirp {\n    author: User\n  }\n`;\n")),Object(s.b)("p",null,"We can now merge these three schemas together:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"export const schema = stitchSchemas({\n  subschemas: [\n    { schema: chirpSchema, },\n    { schema: authorSchema, },\n  ],\n  typeDefs: linkTypeDefs,\n});\n")),Object(s.b)("p",null,"Note the new ",Object(s.b)("inlineCode",{parentName:"p"},"typeDefs")," option in parallel to the new ",Object(s.b)("inlineCode",{parentName:"p"},"subschemas")," option, which better expresses that these typeDefs are defined only within the outer gateway schemas."),Object(s.b)("p",null,"We won't be able to query ",Object(s.b)("inlineCode",{parentName:"p"},"User.chirps")," or ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp.author")," yet, however, because we still need to define resolvers for these new fields."),Object(s.b)("p",null,"How should these resolvers be implemented? When we resolve ",Object(s.b)("inlineCode",{parentName:"p"},"User.chirps")," or ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp.author"),", we want to ",Object(s.b)("em",{parentName:"p"},"delegate")," to the relevant root fields. To get from a user to the user's chirps, for example, we'll want to use the ",Object(s.b)("inlineCode",{parentName:"p"},"id")," of the user to call ",Object(s.b)("inlineCode",{parentName:"p"},"Query.chirpsByAuthorId"),". And to get from a chirp to its author, we can use the chirp's ",Object(s.b)("inlineCode",{parentName:"p"},"authorId")," field to call the existing ",Object(s.b)("inlineCode",{parentName:"p"},"Query.userById")," field."),Object(s.b)("p",null,"Resolvers can use the ",Object(s.b)("inlineCode",{parentName:"p"},"delegateToSchema")," function to forward parts of queries (or even whole new queries) to one of the subschemas that was passed to ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," (or any other schema)."),Object(s.b)("p",null,"In order to delegate to these root fields, we'll need to make sure we've actually requested the ",Object(s.b)("inlineCode",{parentName:"p"},"id")," of the user or the ",Object(s.b)("inlineCode",{parentName:"p"},"authorId")," of the chirp. To avoid forcing users to add these fields to their queries manually, resolvers on a merged schema can define a ",Object(s.b)("inlineCode",{parentName:"p"},"selectionSet")," property that specifies the required fields, and they will be added to the query automatically."),Object(s.b)("p",null,"A complete implementation of schema stitching for these schemas might look like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const schema = stitchSchemas({\n  subschemas: [\n    { schema: chirpSchema, },\n    { schema: authorSchema, },\n  ],\n  typeDefs: linkTypeDefs,\n  resolvers: {\n    User: {\n      chirps: {\n        selectionSet: `{ id }`,\n        resolve(user, args, context, info) {\n          return delegateToSchema({\n            schema: chirpSchema,\n            operation: 'query',\n            fieldName: 'chirpsByAuthorId',\n            args: {\n              authorId: user.id,\n            },\n            context,\n            info,\n          });\n        },\n      },\n    },\n    Chirp: {\n      author: {\n        selectionSet: `{ authorId }`,\n        resolve(chirp, args, context, info) {\n          return delegateToSchema({\n            schema: authorSchema,\n            operation: 'query',\n            fieldName: 'userById',\n            args: {\n              id: chirp.authorId,\n            },\n            context,\n            info,\n          });\n        },\n      },\n    },\n  },\n});\n")),Object(s.b)("h3",{id:"passing-arguments-between-resolvers"},"Passing arguments between resolvers"),Object(s.b)("p",null,"As a stitching implementation scales, we encounter situations where it's impractical to pass around exhaustive sets of records between services. For example, what if a User has tens of thousands of Chirps? We'll want to add scoping arguments into our gateway schema to address this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const linkTypeDefs = `\n  extend type User {\n    chirps(since: DateTime): [Chirp]\n  }\n`;\n")),Object(s.b)("p",null,"This argument in the gateway schema won't do anything until passed through to the underlying subservice requests. How we pass this input through depends on which subservice manages the association data."),Object(s.b)("p",null,"First, let's say that the Chirps service manages the association and implements a ",Object(s.b)("inlineCode",{parentName:"p"},"since")," param for scoping the returned Chirp results. This simply requires passing the resolver argument through to ",Object(s.b)("inlineCode",{parentName:"p"},"delegateToSchema"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"export default {\n  User: {\n    chirps: {\n      selectionSet: `{ id }`,\n      resolve(user, args, context, info) {\n        return delegateToSchema({\n          schema: chirpSchema,\n          operation: 'query',\n          fieldName: 'chirpsByAuthorId',\n          args: {\n            authorId: user.id,\n            since: args.since\n          },\n          context,\n          info,\n        });\n      },\n    },\n  }\n};\n")),Object(s.b)("p",null,"Alternatively, let's say that the Users service manages the association and implements a ",Object(s.b)("inlineCode",{parentName:"p"},"User.chirpIds(since: DateTime):[Int]")," method to stitch from. In this configuration, resolver arguments will need to passthrough with the initial ",Object(s.b)("inlineCode",{parentName:"p"},"selectionSet")," for User data. The ",Object(s.b)("inlineCode",{parentName:"p"},"forwardArgsToSelectionSet")," helper handles this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { forwardArgsToSelectionSet } from '@graphql-tools/stitch';\n\nexport default {\n  User: {\n    chirps: {\n      selectionSet: forwardArgsToSelectionSet('{ chirpIds }'),\n      resolve(user, args, context, info) {\n        return delegateToSchema({\n          schema: chirpSchema,\n          operation: 'query',\n          fieldName: 'chirpsById',\n          args: {\n            ids: user.chirpIds,\n          },\n          context,\n          info,\n        });\n      },\n    },\n  }\n};\n")),Object(s.b)("p",null,"By default, ",Object(s.b)("inlineCode",{parentName:"p"},"forwardArgsToSelectionSet")," will passthrough all arguments from the gateway field to ",Object(s.b)("em",{parentName:"p"},"all")," root fields in the selection set. For complex selections that request multiple fields, you may provide an additional mapping of selection names with their respective arguments:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"forwardArgsToSelectionSet('{ id chirpIds }', { chirpIds: ['since'] })\n")),Object(s.b)("p",null,"Note that a dynamic ",Object(s.b)("inlineCode",{parentName:"p"},"selectionSet")," is simply a function that recieves a GraphQL ",Object(s.b)("inlineCode",{parentName:"p"},"FieldNode")," (the gateway field) and returns a ",Object(s.b)("inlineCode",{parentName:"p"},"SelectionSetNode"),". This dynamic capability can support a wide range of custom stitching configurations."),Object(s.b)("h3",{id:"batch-delegation"},"Batch Delegation"),Object(s.b)("p",null,"Suppose there was an additional root field within the schema for chirps called ",Object(s.b)("inlineCode",{parentName:"p"},"trendingChirps")," that returned a list of the current most popular chirps, as well as an additonal field on the ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp")," type called ",Object(s.b)("inlineCode",{parentName:"p"},"chirpedAtUserId")," that described the target of an individual chirp. Imagine as well that we used the above stitching strategy to add an additional new field on the ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp")," type called ",Object(s.b)("inlineCode",{parentName:"p"},"chirpedAtUser")," so that we could write the following query:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"query {\n  trendingChirps {\n    id\n    text\n    chirpedAtUser {\n      id\n      email\n    }\n  }\n}\n")),Object(s.b)("p",null,"The implementation could be something like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const schema = stitchSchemas({\n  subschemas: [chirpSchema, authorSchema],\n  typeDefs: linkTypeDefs,\n  resolvers: {\n    // ...\n    Chirp: {\n      chirpedAtUser: {\n        selectionSet: `{ chirpedAtUserId }`,\n        resolve(chirp, _args, context, info) {\n          return delegateToSchema({\n            schema: authorSchema,\n            operation: 'query',\n            fieldName: 'userById',\n            args: {\n              id: chirp.chirpedAtUserId,\n            },\n            context,\n            info,\n          });\n        },\n      },\n    },\n    // ...\n  },\n});\n")),Object(s.b)("p",null,"The above query as written would cause the gateway to fire an additional query to our author schema for each trending chirp, with the exact same arguments and selection set!"),Object(s.b)("p",null,"Imagine, however, that the author schema had an additional root field ",Object(s.b)("inlineCode",{parentName:"p"},"usersByIds")," besides just ",Object(s.b)("inlineCode",{parentName:"p"},"userById"),". Because we know that for each member of a list, the arguments and selection set will always match, we can utilize batch delegation using the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.npmjs.com/package/dataloader"}),"DataLoader")," pattern to combine the individual queries from the gateway into one batch to the ",Object(s.b)("inlineCode",{parentName:"p"},"userByIds")," root field instead of ",Object(s.b)("inlineCode",{parentName:"p"},"userById"),". The implementation would look very similar:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { batchDelegateToSchema } from '@graphql-tools/batchDelegate';\n\nconst schema = stitchSchemas({\n  subschemas: [chirpSchema, authorSchema],\n  typeDefs: linkTypeDefs,\n  resolvers: {\n    // ...\n    Chirp: {\n      chirpedAtUser: {\n        selectionSet: `{ chirpedAtUserId }`,\n        resolve(chirp, _args, context, info) {\n          return batchDelegateToSchema({\n            schema: authorSchema,\n            operation: 'query',\n            fieldName: 'usersByIds',\n            key: chirp.chirpedAtUserId,\n            mapKeysFn: (ids) => ({ ids }),\n            context,\n            info,\n          });\n        },\n      },\n    },\n    // ...\n  },\n});\n")),Object(s.b)("p",null,"Batch delegation may be preferable over plain delegation whenever possible, as it reduces the number of requests significantly whenever the parent object type appears in a list!"),Object(s.b)("h2",{id:"using-with-transforms"},"Using with Transforms"),Object(s.b)("p",null,"Often, when creating a GraphQL gateway that combines multiple existing schemas, we might want to modify one of the schemas. The most common tasks include renaming some of the types, and filtering the root fields. By using ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/schema-wrapping"}),"transforms")," with schema stitching, we can easily tweak the subschemas before merging them together. (In earlier versions of graphql-tools, this required an additional round of delegation prior to merging, but transforms can now be specifying directly when merging using the new subschema configuration objects.)"),Object(s.b)("p",null,"For example, suppose we transform the ",Object(s.b)("inlineCode",{parentName:"p"},"chirpSchema")," by removing the ",Object(s.b)("inlineCode",{parentName:"p"},"chirpsByAuthorId")," field and add a ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp_")," prefix to all types and field names, in order to make it very clear which types and fields came from ",Object(s.b)("inlineCode",{parentName:"p"},"chirpSchema"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { makeExecutableSchema } from '@graphql-tools/schema';\nimport { addMocksToSchema } from '@graphql-tools/mock';\nimport { stitchSchemas } from '@graphql-tools/stitch';\nimport {\n  FilterRootFields,\n  RenameTypes,\n  RenameRootFields,\n} from '@graphql-tools/wrap';\n\n// Mocked chirp schema; we don't want to worry about the schema\n// implementation right now since we're just demonstrating\n// schema stitching\nlet chirpSchema = makeExecutableSchema({\n  typeDefs: `\n    type Chirp {\n      id: ID!\n      text: String\n      authorId: ID!\n    }\n\n    type Query {\n      chirpById(id: ID!): Chirp\n      chirpsByAuthorId(authorId: ID!): [Chirp]\n    }\n  `\n});\n\nchirpSchema = addMocksToSchema({ schema: chirpSchema });\n\n// create transforms\n\nconst chirpSchemaTransforms = [\n  new FilterRootFields(\n    (operation: string, rootField: string) => rootField !== 'chirpsByAuthorId'\n  ),\n  new RenameTypes((name: string) => `Chirp_${name}`),\n  new RenameRootFields((operation: 'Query' | 'Mutation' | 'Subscription', name: string) => `Chirp_${name}`),\n];\n")),Object(s.b)("p",null,"We will now have a schema that has all fields and types prefixed with ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp_")," and has only the ",Object(s.b)("inlineCode",{parentName:"p"},"chirpById")," root field."),Object(s.b)("p",null,"Now let's implement the resolvers:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const chirpSubschema = {\n  schema: chirpSchema,\n  transforms: chirpSchemaTransforms,\n}\n\nexport const schema = stitchSchemas({\n  subschemas: [\n    chirpSubschema,\n    { schema: authorSchema },\n  ],\n  typeDefs: linkTypeDefs,\n\n  resolvers: {\n    User: {\n      chirps: {\n        selectionSet: `{ id }`,\n        resolve(user, args, context, info) {\n          return delegateToSchema({\n            schema: chirpSubschema,\n            operation: 'query',\n            fieldName: 'chirpsByAuthorId',\n            args: {\n              authorId: user.id,\n            },\n            context,\n            info,\n          });\n        },\n      },\n    },\n    Chirp_Chirp: {\n      author: {\n        selectionSet: `{ authorId }`,\n        resolve(chirp, args, context, info) {\n          return delegateToSchema({\n            schema: authorSchema,\n            operation: 'query',\n            fieldName: 'userById',\n            args: {\n              id: chirp.authorId,\n            },\n            context,\n            info,\n          });\n        },\n      },\n    },\n  },\n});\n")),Object(s.b)("p",null,"Notice that when we call ",Object(s.b)("inlineCode",{parentName:"p"},"delegateToSchema")," in the ",Object(s.b)("inlineCode",{parentName:"p"},"User.chirps")," resolvers, we can delegate to the original ",Object(s.b)("inlineCode",{parentName:"p"},"chirpsByAuthorId")," field, even though it has been filtered out of the final schema."),Object(s.b)("h2",{id:"merging-types"},"Merging types"),Object(s.b)("p",null,"We are still stuck exposing the ",Object(s.b)("inlineCode",{parentName:"p"},"authorId")," field within the ",Object(s.b)("inlineCode",{parentName:"p"},"Chirp")," type even though we actually just want to include an ",Object(s.b)("inlineCode",{parentName:"p"},"author"),". We can always use transforms to filter out the ",Object(s.b)("inlineCode",{parentName:"p"},"authorId")," field, but it would be nice if this could be made more ergonomical. It also makes stitching somewhat more difficult when the authorId is not directly exposed -- for example, in a situation where we do not control the remote subschema in question."),Object(s.b)("p",null,"What is the chirps subschema also had its own self-contained user concept, and we just wanted to combine the relevant fields from both subschemas?"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"let chirpSchema = makeExecutableSchema({\n  typeDefs: `\n    type Chirp {\n      id: ID!\n      text: String\n      author: User\n    }\n\n    type User {\n      id: ID!\n      chirps: [Chirp]\n    }\n\n    type Query {\n      chirpById(id: ID!): Chirp\n      chirpsByUserId(id: ID!): [Chirp]\n      userById(id: ID!): User\n    }\n  `\n});\n\nchirpSchema = addMocksToSchema({ schema: chirpSchema });\n\n// Mocked author schema\nlet authorSchema = makeExecutableSchema({\n  typeDefs: `\n    type User {\n      id: ID!\n      email: String\n    }\n\n    type Query {\n      userById(id: ID!): User\n    }\n  `\n});\n\nauthorSchema = addMocksToSchema({ schema: authorSchema });\n")),Object(s.b)("p",null,"This can now be accomplished by turning on type merging!"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const stitchedSchema = stitchSchemas({\n  subschemas: [\n    {\n      schema: chirpSchema,\n      merge: {\n        User: {\n          fieldName: 'userById',\n          args: (originalResult) => ({ id: originalResult.id }),\n          selectionSet: '{ id }',\n        },\n      },\n    },\n    {\n      schema: authorSchema,\n      merge: {\n        User: {\n          fieldName: 'userById',\n          args: (originalResult) => ({ id: originalResult.id }),\n          selectionSet: '{ id }',\n        },\n      },\n    },\n  ],\n  mergeTypes: true,\n});\n")),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"merge")," property on the ",Object(s.b)("inlineCode",{parentName:"p"},"SubschemaConfig")," object determines how types are merged, and is a map of ",Object(s.b)("inlineCode",{parentName:"p"},"MergedTypeConfig")," objects:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export interface MergedTypeConfig {\n  selectionSet?: string;\n  resolve?: MergedTypeResolver;\n  fieldName?: string;\n  args?: (originalResult: any) => Record<string, any>;\n  key?: (originalResult: any) => K;\n  mapKeysFn?: (keys: ReadonlyArray<K>) => Record<string, any>;\n  mapResultsFn?: (results: any, keys: ReadonlyArray<K>) => Array<V>;\n}\n\nexport type MergedTypeResolver = (\n  originalResult: any, // initial final result from a subschema\n  context: Record<string, any>, // gateway context\n  info: GraphQLResolveInfo, // gateway info\n  subschema: GraphQLSchema | SubschemaConfig, // the additional implementing subschema from which to retrieve data\n  selectionSet: SelectionSetNode // the additional fields required from that subschema\n) => any;\n")),Object(s.b)("p",null,"Type merging simply merges types with the same name, but is smart enough to apply the passed subschema transforms prior to merging types, so the types have to be identical on the gateway, not the individual subschema."),Object(s.b)("p",null,"All merged types returned by any subschema will delegate as necessary to subschemas also implementing the type, using the provided ",Object(s.b)("inlineCode",{parentName:"p"},"resolve")," function of type ",Object(s.b)("inlineCode",{parentName:"p"},"MergedTypeResolver"),"."),Object(s.b)("p",null,"You can also use batch delegation instead of simple delegation by delegating to a root field returning a list and using the ",Object(s.b)("inlineCode",{parentName:"p"},"key"),", ",Object(s.b)("inlineCode",{parentName:"p"},"mapKeysFn"),", and ",Object(s.b)("inlineCode",{parentName:"p"},"mapResultsFn")," properties. See the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"#batch-delegation"}),"batch delegation")," for more details."),Object(s.b)("p",null,"The simplified magic above happens because if left unspecified, we provide a default type-merging resolver for you, which uses the other ",Object(s.b)("inlineCode",{parentName:"p"},"MergedTypeConfig")," options (for simple delegation), as follows:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"mergedTypeConfig.resolve = (originalResult, context, info, schemaOrSubschemaConfig, selectionSet) =>\n  delegateToSchema({\n    schema: schemaOrSubschemaConfig,\n    operation: 'query',\n    fieldName: mergedTypeConfig.fieldName,\n    returnType: getNamedType(info.returnType),\n    args: mergedTypeConfig.args(originalResult),\n    selectionSet,\n    context,\n    info,\n    skipTypeMerging: true,\n  });\n")),Object(s.b)("p",null,"When providing your own type-merging resolver, note the very important ",Object(s.b)("inlineCode",{parentName:"p"},"skipTypeMerging")," setting. Without this option, your gateway will keep busy merging types forever, as each result returned from each subschema will trigger another round of delegation to the other implementing subschemas!"),Object(s.b)("p",null,"Finally, you may wish to fine-tune which types are merged. Besides taking a boolean value, you can also specify an array of type names, or a function of type ",Object(s.b)("inlineCode",{parentName:"p"},"MergeTypeFilter")," that takes the potential types and decides dynamically how to merge."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export type MergeTypeCandidate = {\n  type: GraphQLNamedType;\n  subschema?: GraphQLSchema | SubschemaConfig; // undefined if the type is added to the gateway directly, not from a subschema\n  transformedSubschema?: GraphQLSchema; // the target schema of the above after any subschema config schema transformations are applied\n};\n\nexport type MergeTypeFilter = (mergeTypeCandidates: Array<MergeTypeCandidate>, typeName: string) => boolean;\n")),Object(s.b)("h2",{id:"working-with-remote-schemas"},"Working with remote schemas"),Object(s.b)("p",null,"In order to merge with a remote schema, we specify different options within the subschema configuration object that describe how to connect to the remote schema. For example:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"  subschemas: [\n    {\n      schema: nonExecutableChirpSchema,\n      executor: chirpSchemaExecutor,\n      transforms: chirpSchemaTransforms,\n    },\n    { schema: authorSchema },\n  ],\n")),Object(s.b)("p",null,"The remote schema may be obtained either via introspection or any other source. An executor is a generic method of connecting to a schema."),Object(s.b)("p",null,"Specifying the remote schema options within the ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," call itself allows for skipping an additional round of delegation. The old method of using ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/remote-schemas/"}),"makeRemoteExecutableSchema")," to create a local proxy for the remote schema would still work, and the same arguments are supported. See the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/remote-schemas/"}),"remote schema")," docs for further description of the options available. Subschema configuration allows for specifying an executor method for query and mutation operations, and a subscriber function for subscription operations."),Object(s.b)("h2",{id:"api"},"API"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"export type SubschemaConfig = {\n  schema: GraphQLSchema;\n  rootValue?: Record<string, any>;\n  executor?: Executor;\n  subscriber?: Subscriber;\n  transforms?: Array<Transform>;\n};\n\nexport type SchemaLikeObject =\n  SubschemaConfig |\n  GraphQLSchema |\n  string |\n  DocumentNode |\n  Array<GraphQLNamedType>;\n\nstitchSchemas({\n  subschemas: Array<SubschemaConfig>;\n  types: Array<GraphQLNamedType>;\n  typeDefs: string | DocumentNode;\n  schemas: Array<SchemaLikeObject>;\n  resolvers?: Array<IResolvers> | IResolvers;\n  onTypeConflict?: (\n    left: GraphQLNamedType,\n    right: GraphQLNamedType,\n    info?: {\n      left: {\n        schema?: GraphQLSchema;\n      };\n      right: {\n        schema?: GraphQLSchema;\n      };\n    },\n  ) => GraphQLNamedType;\n})\n")),Object(s.b)("p",null,"This is the main function that implements schema stitching. Note that in addition to the above arguments, the function also takes all the same arguments as ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/generate-schema/"}),Object(s.b)("inlineCode",{parentName:"a"},"makeExecutableSchema")),". Read below for a description of each option."),Object(s.b)("h3",{id:"subschemas"},"subschemas"),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"subschemas")," is an array of ",Object(s.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," or ",Object(s.b)("inlineCode",{parentName:"p"},"SubschemaConfig")," objects. These subschemas are wrapped with proxying resolvers in the final schema."),Object(s.b)("h3",{id:"types"},"types"),Object(s.b)("p",null,"Additional types to add to the final type map, most useful for custom scalars or enums."),Object(s.b)("h3",{id:"typedefs"},"typeDefs"),Object(s.b)("p",null,"Strings or parsed documents that can contain additional types or type extensions. Note that type extensions are always applied last, while types are defined in the order in which they are provided."),Object(s.b)("h3",{id:"resolvers"},"resolvers"),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"resolvers")," accepts resolvers in same format as ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/resolvers/"}),"makeExecutableSchema"),". It can also take an Array of resolvers. One addition to the resolver format is the possibility to specify a ",Object(s.b)("inlineCode",{parentName:"p"},"selectionSet")," for a resolver. The ",Object(s.b)("inlineCode",{parentName:"p"},"selectionSet")," must be a GraphQL selection set definition string, specifying which fields from the parent schema are required for the resolver to function properly."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"resolvers: {\n  Booking: {\n    property: {\n      selectionSet: '{ propertyId }',\n      resolve(parent, args, context, info) {\n        return delegateToSchema({\n          schema: bookingSchema,\n          operation: 'query',\n          fieldName: 'propertyById',\n          args: {\n            id: parent.propertyId,\n          },\n          context,\n          info,\n        });\n      },\n    },\n  },\n}\n")),Object(s.b)("h3",{id:"delegatetoschema"},"delegateToSchema"),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"delegateToSchema")," method:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"delegateToSchema<TContext>(options: IDelegateToSchemaOptions<TContext>): any;\n\ninterface IDelegateToSchemaOptions<TContext = Record<string, any>> {\n    schemaOrSchemaConfig: GraphQLSchema | SubschemaConfig;\n    operation: Operation;\n    fieldName: string;\n    args?: Record<string, any>;\n    context: TContext;\n    info: GraphQLResolveInfo;\n    transforms?: Array<Transform>;\n}\n")),Object(s.b)("p",null,"As described in the documentation above, ",Object(s.b)("inlineCode",{parentName:"p"},"delegateToSchema")," allows delegating to any ",Object(s.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," or ",Object(s.b)("inlineCode",{parentName:"p"},"SubschemaConfig")," object. Transforms do not have to be re-specified when passing a ",Object(s.b)("inlineCode",{parentName:"p"},"SubschemaConfig")," object, which is the preserved workflow. Additional transforms can also be passed as needed. See ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/schema-delegation/"}),"Schema Delegation")," and the ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"#using-with-transforms"}),Object(s.b)("em",{parentName:"a"},"Using with transforms"))," section of this document."),Object(s.b)("h4",{id:"ontypeconflict"},"onTypeConflict"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"type OnTypeConflict = (\n  left: GraphQLNamedType,\n  right: GraphQLNamedType,\n  info?: {\n    left: {\n      schema?: GraphQLSchema;\n    };\n    right: {\n      schema?: GraphQLSchema;\n    };\n  },\n) => GraphQLNamedType;\n")),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"onTypeConflict")," option to ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," allows customization of type resolving logic."),Object(s.b)("p",null,"The default behavior of ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," is to take the ",Object(s.b)("em",{parentName:"p"},"last")," encountered type of all the types with the same name, with a warning that type conflicts have been encountered. If specified, ",Object(s.b)("inlineCode",{parentName:"p"},"onTypeConflict")," enables explicit selection of the winning type."),Object(s.b)("p",null,"For example, here's how we could select the ",Object(s.b)("em",{parentName:"p"},"first")," type among multiple types with the same name:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const onTypeConflict = (left, right) => left;\n")),Object(s.b)("p",null,"And here's how we might select the type whose schema has the latest ",Object(s.b)("inlineCode",{parentName:"p"},"version"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const onTypeConflict = (left, right, info) => {\n  if (info.left.schema.version >= info.right.schema.version) {\n    return left;\n  } else {\n    return right;\n  }\n}\n")),Object(s.b)("p",null,"When using schema transforms, ",Object(s.b)("inlineCode",{parentName:"p"},"onTypeConflict")," is often unnecessary, since transforms can be used to prevent conflicts before merging schemas. However, if you're not using schema transforms, ",Object(s.b)("inlineCode",{parentName:"p"},"onTypeConflict")," can be a quick way to make ",Object(s.b)("inlineCode",{parentName:"p"},"stitchSchemas")," produce more desirable results."),Object(s.b)("h4",{id:"inheritresolversfrominterfaces"},"inheritResolversFromInterfaces"),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"inheritResolversFromInterfaces")," option is simply passed through to ",Object(s.b)("inlineCode",{parentName:"p"},"addResolversToSchema"),", which is called when adding resolvers to the schema under the covers. See ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/resolvers/#addresolverstoschema-schema-resolvers-resolvervalidationoptions-inheritresolversfrominterfaces-"}),Object(s.b)("inlineCode",{parentName:"a"},"addResolversToSchema"))," for more info."))}l.isMDXComponent=!0},189:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var h=r.a.createContext({}),l=function(e){var t=r.a.useContext(h),n=t;return e&&(n="function"==typeof e?e(t):o({},t,{},e)),n},p=function(e){var t=l(e.components);return r.a.createElement(h.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,h=c(e,["components","mdxType","originalType","parentName"]),p=l(n),d=a,b=p["".concat(i,".").concat(d)]||p[d]||m[d]||s;return n?r.a.createElement(b,o({ref:t},h,{components:n})):r.a.createElement(b,o({ref:t},h))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var h=2;h<s;h++)i[h]=n[h];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);