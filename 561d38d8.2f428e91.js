(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{105:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return p})),t.d(n,"default",(function(){return c}));var r=t(2),a=t(6),l=(t(0),t(193)),i={id:"merge-typedefs",title:"Type definitions (SDL) merging",sidebar_label:"Type definitions (SDL) merging"},o={unversionedId:"merge-typedefs",id:"merge-typedefs",isDocsHomePage:!1,title:"Type definitions (SDL) merging",description:"Originally implemented in graphql-modules. This tools merged GraphQL type definitions and schema. It aims to merge all possible types, interfaces, enums and unions, without conflicts.",source:"@site/docs/merge-typedefs.md",permalink:"/docs/merge-typedefs",editUrl:"https://github.com/ardatan/graphql-tools/edit/master/website/docs/merge-typedefs.md",sidebar_label:"Type definitions (SDL) merging",sidebar:"someSidebar",previous:{title:"Schema wrapping",permalink:"/docs/schema-wrapping"},next:{title:"Resolvers merging",permalink:"/docs/merge-resolvers"}},p=[{value:"Usage",id:"usage",children:[{value:"Manually import each type",id:"manually-import-each-type",children:[]},{value:"Import everything from a specified folder",id:"import-everything-from-a-specified-folder",children:[]},{value:"Output the string of typeDefs",id:"output-the-string-of-typedefs",children:[]},{value:"Merging nested Types",id:"merging-nested-types",children:[]},{value:"Merging Directives",id:"merging-directives",children:[]}]}],s={rightToc:p};function c(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(l.b)("wrapper",Object(r.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("p",null,"Originally implemented in ",Object(l.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/Urigo/graphql-modules"}),"graphql-modules"),". This tools merged GraphQL type definitions and schema. It aims to merge all possible types, interfaces, enums and unions, without conflicts."),Object(l.b)("h2",{id:"usage"},"Usage"),Object(l.b)("p",null,"Let's say this is your current schema:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"type Client {\n  id: ID!\n  name: String\n  age: Int\n  products: [Product]\n}\n\ntype Product {\n  id: ID!\n  description: String\n  price: Int\n}\n\ntype Query {\n  clients: [Client]\n  client(id: ID!): Client\n  products: [Product]\n  product(id: ID!): Product\n}\n\ntype Mutation {\n  addClient(name: String!, age: Int!): Client\n}\n")),Object(l.b)("p",null,"Knowing that your app will grow, you want to move your definitions to separate files that should look like the following."),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"// ./graphql/types/clientType.js\nmodule.exports = `\n  type Client {\n    id: ID!\n    name: String\n    age: Int\n    products: [Product]\n  }\n\n  type Query {\n    clients: [Client]\n    client(id: ID!): Client\n  }\n\n  type Mutation {\n    addClient(name: String!, age: Int!): Client\n  }\n`;\n\n// ./graphql/types/productType.js\nmodule.exports =  `\n  type Product {\n    id: ID!\n    description: String\n    price: Int\n    client: Client\n  }\n\n  type Query {\n    products: [Product]\n    product(id: ID!): Product\n  }\n`;\n")),Object(l.b)("p",null,"There are two ways you can use this package:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"manually import each type"),Object(l.b)("li",{parentName:"ul"},"import everything from a specified folder")),Object(l.b)("h3",{id:"manually-import-each-type"},"Manually import each type"),Object(l.b)("p",null,"If you decide to have manual control of each file that gets merged, all you need is the ",Object(l.b)("inlineCode",{parentName:"p"},"mergeTypeDefs(types)")," function from ",Object(l.b)("inlineCode",{parentName:"p"},"@graphql-tools/merge")," package:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const { mergeTypeDefs } = require('@graphql-tools/merge');\nconst clientType = require('./clientType');\nconst productType = require('./productType');\n\nconst types = [\n  clientType,\n  productType,\n];\n\nmodule.exports = mergeTypeDefs(types);\n")),Object(l.b)("p",null,"See ",Object(l.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.graphql-tools.com/docs/api/modules/merge/#mergetypedefs"}),Object(l.b)("inlineCode",{parentName:"a"},"mergeTypeDefs"))," for more details."),Object(l.b)("h3",{id:"import-everything-from-a-specified-folder"},"Import everything from a specified folder"),Object(l.b)("p",null,"In this way we use the ",Object(l.b)("inlineCode",{parentName:"p"},"loadFilesSync")," function from ",Object(l.b)("inlineCode",{parentName:"p"},"@graphql-tools/load-files")," to import all files from the specified folder."),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"// ./graphql/typeDefs.js\nconst path = require('path');\nconst { loadFilesSync } = require('@graphql-tools/load-files');\nconst { mergeTypeDefs } = require('@graphql-tools/merge');\n\nconst typesArray = loadFilesSync(path.join(__dirname, './types'));\n\nmodule.exports = mergeTypeDefs(typesArray, { all: true });\n")),Object(l.b)("p",null,"When using the ",Object(l.b)("inlineCode",{parentName:"p"},"loadFilesSync")," function you can also implement your type definitions using ",Object(l.b)("inlineCode",{parentName:"p"},".graphql")," or ",Object(l.b)("inlineCode",{parentName:"p"},".gql")," or ",Object(l.b)("inlineCode",{parentName:"p"},".graphqls")," files."),Object(l.b)("p",null,"You can also load files with specified extensions by setting the extensions option.\nOnly these values are supported now. ",Object(l.b)("inlineCode",{parentName:"p"},"'ts', 'js', 'gql', 'graphql', 'graphqls'")),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"// ./graphql/typeDefs.js\nconst path = require('path');\nconst { loadFilesSync } = require('@graphql-tools/load-files');\nconst { mergeTypeDefs } = require('@graphql-tools/merge');\n\nconst typesArray = loadFilesSync(path.join(__dirname, './types'), { extensions: ['graphql'] });\n\nmodule.exports = mergeTypeDefs(typesArray, { all: true });\n")),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"By default, the ",Object(l.b)("inlineCode",{parentName:"p"},"loadFilesSync")," function will not ignore files named ",Object(l.b)("inlineCode",{parentName:"p"},"index.js")," or ",Object(l.b)("inlineCode",{parentName:"p"},"index.ts"),", but you can set the ",Object(l.b)("inlineCode",{parentName:"p"},"ignoreIndex")," option to ",Object(l.b)("inlineCode",{parentName:"p"},"true")," to enable this behavior. This allows you to create your index file inside the actual types folder if desired.")),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"# ./graphql/types/clientType.graphql\ntype Client {\n  id: ID!\n  name: String\n  age: Int\n  products: [Product]\n}\n\ntype Query {\n  clients: [Client]\n  client(id: ID!): Client\n}\n\ntype Mutation {\n  addClient(name: String!, age: Int!): Client\n}\n\n# ./graphql/types/productType.graphql\ntype Product {\n  id: ID!\n  description: String\n  price: Int\n  client: Client\n}\n\ntype Query {\n  products: [Product]\n  product(id: ID!): Product\n}\n")),Object(l.b)("p",null,"You can also load files in nested folders by setting the ",Object(l.b)("inlineCode",{parentName:"p"},"recursive")," option."),Object(l.b)("p",null,"Given the file structure below:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{}),"+-- graphql\n|   +-- types\n|   |   +-- subGroupA\n|   |   |   +-- typeA1.graphql\n|   |   |   +-- typeA2.graphql\n|   |   +-- subGroupB\n|   |   |   +-- typeB1.graphql\n|   |   |   +-- typeB2.graphql\n|   |   +-- index.js\n")),Object(l.b)("p",null,"Here's how your ",Object(l.b)("inlineCode",{parentName:"p"},"index")," file could look like:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const path = require('path');\nconst { loadFilesSync } = require('@graphql-tools/load-files');\nconst { mergeTypeDefs } = require('@graphql-tools/merge');\n\nconst typesArray = loadFilesSync(path.join(__dirname, '.'), { recursive: true })\n\nmodule.exports = mergeTypeDefs(typesArray, { all: true })\n")),Object(l.b)("p",null,"You can also load files in different folders by passing a glob pattern in ",Object(l.b)("inlineCode",{parentName:"p"},"loadFilesSync"),"."),Object(l.b)("p",null,"Given the file structure below:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{}),"+-- graphql\n|   +-- subGroupA\n|   |   +-- typeA1.graphql\n|   |   +-- typeA2.graphql\n|   +-- subGroupB\n|   |   +-- typeB1.graphql\n|   |   +-- typeB2.graphql\n|   +-- index.js\n")),Object(l.b)("p",null,"Here's how your ",Object(l.b)("inlineCode",{parentName:"p"},"index")," file could look like:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const path = require('path');\nconst { loadFilesSync } = require('@graphql-tools/load-files');\nconst { mergeTypeDefs } = require('@graphql-tools/merge');\n\nconst typesArray = loadFilesSync(path.join(__dirname, 'graphql/**/*.graphql'))\n\nmodule.exports = mergeTypeDefs(typesArray, { all: true })\n")),Object(l.b)("h3",{id:"output-the-string-of-typedefs"},"Output the string of typeDefs"),Object(l.b)("p",null,"Since the output of ",Object(l.b)("inlineCode",{parentName:"p"},"mergeTypeDefs")," is ",Object(l.b)("inlineCode",{parentName:"p"},"DocumentNode"),", after you merge your types, you can save it to a file to be passed around to other systems. Here is an example using ES6 modules:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const { loadFilesSync } = require('@graphql-tools/load-files');\nconst { mergeTypeDefs } = require('@graphql-tools/merge');\nconst { print } = require('graphql');\nconst fs = require('fs');\n\nconst loadedFiles = loadFilesSync(`${__dirname}/schema/**/*.graphql`);\nconst typeDefs = mergeTypeDefs(loadedFiles, { all: true });\nconst printedTypeDefs = print(typeDefs);\nfs.writeFileSync('joined.graphql', printedTypeDefs);\n")),Object(l.b)("h3",{id:"merging-nested-types"},"Merging nested Types"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"mergeTypeDefs")," function also allows merging multiple schemas. In the situations where you would like to have multiple\ntypes subfolders, you can merge your types on each subfolder and then everything into one single schema. See the example below:"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{}),"+-- graphql\n|   +-- types\n|   |   +-- subGroupA\n|   |   |   +-- index.js <<< Merges all types in subGroupA\n|   |   |   +-- typeA1.graphql\n|   |   |   +-- typeA2.graphql\n|   |   +-- subGroupB\n|   |   |   +-- index.js <<< Merges all types in subGroupB\n|   |   |   +-- typeB1.graphql\n|   |   |   +-- typeB2.graphql\n|   |   +-- index.js <<< Merges exports from subGroupA and subGroupB\n")),Object(l.b)("h3",{id:"merging-directives"},"Merging Directives"),Object(l.b)("p",null,"Directives will be stacked on top of each other, in the order of declaration."),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"type Query {\n  client: Client @foo\n}\ntype Query {\n  client: Client @bar\n}\n")),Object(l.b)("p",null,"Becomes"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{}),"type Query {\n  client: Client @foo @bar\n}\n")))}c.isMDXComponent=!0},193:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return y}));var r=t(0),a=t.n(r);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=a.a.createContext({}),c=function(e){var n=a.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o({},n,{},e)),t},u=function(e){var n=c(e.components);return a.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},b=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=c(t),b=r,y=u["".concat(i,".").concat(b)]||u[b]||d[b]||l;return t?a.a.createElement(y,o({ref:n},s,{components:t})):a.a.createElement(y,o({ref:n},s))}));function y(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=b;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var s=2;s<l;s++)i[s]=t[s];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);